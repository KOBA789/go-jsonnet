// generated by jsonenums -type=BinaryOp; DO NOT EDIT

package ast

import (
	"encoding/json"
	"fmt"
)

var (
	_BinaryOpNameToValue = map[string]BinaryOp{
		"BopMult":            BopMult,
		"BopDiv":             BopDiv,
		"BopPercent":         BopPercent,
		"BopPlus":            BopPlus,
		"BopMinus":           BopMinus,
		"BopShiftL":          BopShiftL,
		"BopShiftR":          BopShiftR,
		"BopGreater":         BopGreater,
		"BopGreaterEq":       BopGreaterEq,
		"BopLess":            BopLess,
		"BopLessEq":          BopLessEq,
		"BopIn":              BopIn,
		"BopManifestEqual":   BopManifestEqual,
		"BopManifestUnequal": BopManifestUnequal,
		"BopBitwiseAnd":      BopBitwiseAnd,
		"BopBitwiseXor":      BopBitwiseXor,
		"BopBitwiseOr":       BopBitwiseOr,
		"BopAnd":             BopAnd,
		"BopOr":              BopOr,
	}

	_BinaryOpValueToName = map[BinaryOp]string{
		BopMult:            "BopMult",
		BopDiv:             "BopDiv",
		BopPercent:         "BopPercent",
		BopPlus:            "BopPlus",
		BopMinus:           "BopMinus",
		BopShiftL:          "BopShiftL",
		BopShiftR:          "BopShiftR",
		BopGreater:         "BopGreater",
		BopGreaterEq:       "BopGreaterEq",
		BopLess:            "BopLess",
		BopLessEq:          "BopLessEq",
		BopIn:              "BopIn",
		BopManifestEqual:   "BopManifestEqual",
		BopManifestUnequal: "BopManifestUnequal",
		BopBitwiseAnd:      "BopBitwiseAnd",
		BopBitwiseXor:      "BopBitwiseXor",
		BopBitwiseOr:       "BopBitwiseOr",
		BopAnd:             "BopAnd",
		BopOr:              "BopOr",
	}
)

func init() {
	var v BinaryOp
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_BinaryOpNameToValue = map[string]BinaryOp{
			interface{}(BopMult).(fmt.Stringer).String():            BopMult,
			interface{}(BopDiv).(fmt.Stringer).String():             BopDiv,
			interface{}(BopPercent).(fmt.Stringer).String():         BopPercent,
			interface{}(BopPlus).(fmt.Stringer).String():            BopPlus,
			interface{}(BopMinus).(fmt.Stringer).String():           BopMinus,
			interface{}(BopShiftL).(fmt.Stringer).String():          BopShiftL,
			interface{}(BopShiftR).(fmt.Stringer).String():          BopShiftR,
			interface{}(BopGreater).(fmt.Stringer).String():         BopGreater,
			interface{}(BopGreaterEq).(fmt.Stringer).String():       BopGreaterEq,
			interface{}(BopLess).(fmt.Stringer).String():            BopLess,
			interface{}(BopLessEq).(fmt.Stringer).String():          BopLessEq,
			interface{}(BopIn).(fmt.Stringer).String():              BopIn,
			interface{}(BopManifestEqual).(fmt.Stringer).String():   BopManifestEqual,
			interface{}(BopManifestUnequal).(fmt.Stringer).String(): BopManifestUnequal,
			interface{}(BopBitwiseAnd).(fmt.Stringer).String():      BopBitwiseAnd,
			interface{}(BopBitwiseXor).(fmt.Stringer).String():      BopBitwiseXor,
			interface{}(BopBitwiseOr).(fmt.Stringer).String():       BopBitwiseOr,
			interface{}(BopAnd).(fmt.Stringer).String():             BopAnd,
			interface{}(BopOr).(fmt.Stringer).String():              BopOr,
		}
	}
}

// MarshalJSON is generated so BinaryOp satisfies json.Marshaler.
func (r BinaryOp) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _BinaryOpValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid BinaryOp: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so BinaryOp satisfies json.Unmarshaler.
func (r *BinaryOp) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("BinaryOp should be a string, got %s", data)
	}
	v, ok := _BinaryOpNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid BinaryOp %q", s)
	}
	*r = v
	return nil
}
